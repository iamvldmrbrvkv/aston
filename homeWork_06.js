// Домашнее задание(Порешать типовые задачи - написать порядок и вывод в консоли):
// 1)
console.log("1"); // 1. попадает в стек и выполняется, лог 1
setTimeout(() => console.log("2"), 1); // 5. выполняется асинхронно, колбек улетает в очередь макрозадач и выполнится сразу после микрозадач
let promiseNew = new Promise((resolve) => {
  console.log("3"); // 2. попадает в стек с сразу выполняется, лог 3
  resolve(); // синхронно выполняется функция resolve
});
promiseNew.then(() => console.log("4")); // 4, асинхронно колбек в then улетает в очередь микрозадач и выполнится сразу как будет пустой стек
setTimeout(() => console.log("5")); // 6. асинхронно колбек улетает в очеред макрозадач и выполнится после микрозадач если стек будет пуст
console.log("6"); // попадает в стек и сразу выполняется, лог 6
// итог логов 1, 3, 6, 4, 2, 5
// 2)
let promiseTree = new Promise((resolve, reject) => {
  resolve("a"); // функция resolve синхронно выполнится и вернет "a"
  console.log("1"); // 1. синхронно выполняется лог 1
  setTimeout(() => {
    console.log("2"); // 3, асинхронно колбек улетает в очередь макрозадач и выполнится когда стек будет пуст
  }, 0);
  console.log("3"); // 2. синхронно выполняется лог 3
});
// итого логов 1, 3, 2
// 3)
let promiseTwo = new Promise((resolve, reject) => {
  resolve("a"); // синхронно выполняется функция resolve со значением "a"
});
promiseTwo // promiseTwo разрешился со значением "a"
  .then((res) => {
    // в колбеке мы передаем значение "a" и возвращаем "a" "b"
    return res + "b";
  }) // метод then вернул промис который разрешился со значением ab
  .then((res) => {
    // передаем значение ab в колбек который возращает ab + c
    return res + "с";
  }) // метод then вернул промис со значением abc
  .finally((res) => {
    // игнорируется значение успешно выполненого промиса abc
    return res + "!!!!!!!";
  }) // возврашается эквивалентый промис со значением abc
  .catch((res) => {
    // в методе catch колбек для обработки отклоненого промиса
    return res + "d";
  }) // так как у нас успешновыполненный промис, то метод catch вернет успешновыполеннный промис с соответствующим значением abc
  .then((res) => {
    // обрабатываем результат (abc) успешновыполненного промиса
    console.log(res); // логируется результат abc
  });
// 4)
function doSmth() {
  return Promise.resolve("123");
}
doSmth() // функциия возвращает успешновыполеннный промис со значением 123
  .then(function (a) {
    // обрабатываем значение 123 успешновыполненного промиса
    console.log("1", a); // логируется "1" и значение 123
    return a; // возвращаем
  }) // метод then вернул успешновыполеннный промис со значением 123, так как в колбеке мы просто вернули значение которое принимал метод then от предыдущего промиса
  .then(function (b) {
    // обрабатываем значение 123 успешновыполненного промиса
    console.log("2", b); // логируется "2" и значение 123

    return Promise.reject("321"); // возращаем отклоненный промис со значением 321
  }) // так как предыдущий then внутри себя вернул отклоненный промис со значением 123, то промис который вернулся в результате вызова then отклоняется со значением этого обещания в качестве значения
  .catch(function (err) {
    // обрабатываем значение 321
    console.log("3", err); // логируется "3" и значение 321
  }) // так как мы предоставили корректный обработчик для отклонненного промиса но не вернули это отклоненное значение (321), а лишь логировали его, то результатом вызова catch будет просто успешновыполенный промис со значением undefined
  .then(function (c) {
    // обрабатываем значения (undefined) успешновыполненного промиса
    console.log("4", c); // логируется "4" и undefined
    return c; // возвращаем undefined
  });
// 5)
console.log("1"); // 1. выполняется сразу, логируется 1
setTimeout(function () {
  console.log("2"); // 4. улетает в апи и через очередь макрозадач попадет опять в стек если он пустой и в очереди микрозадач нет функций для выполнения
}, 0);
Promise.resolve().then(() => console.log("3")); // 3. колбек улетает в очередь микрозадач и выполняется когда стек будет пустой и залогируется 3
console.log("4"); // 2. выполняется сразу и логируется 4
// итог логов 1, 4, 3, 2
// 6) Напишите функцию, которая будет проходить через массив целых чисел и выводить индекс каждого
// элемента с задержкой в 3 секунды.
// Входные данные: [10, 12, 15, 21]
let arr = [10, 12, 15, 21];

function myFunc(arr) {
  for (let i = 0; i < arr.length; i++) {
    setTimeout(() => {
      // setTimeout запускается для каждого прохода и логирует текущий индекс с задержкой
      console.log(i);
    }, 3000 * i); // вывод индекса с задержкой в 3 секунды, нулевой индекс залонируется сразу, так как 3000 * 0 = 0, 1 индекс залогируется через 3 секунд, так как 3000 * 1 = 3000 и так далее
  }
}

myFunc(arr);

// 7) Прочитать про Top Level Await (можно ли использовать await вне функции async)
// Можно использовать, например когда мы экпортируем переменную, которая хранит результат асинхронного операции, к примеру let result = await fetch(...); await result содержит результат звонка на сервер, если экспортируем эту переменную в другой модуль, то весь код в этом модуле использующий переменную result будет ожидать когда мы получим значение этой переменной, позже  этот код через очередь микротасок попадет в стек и выполнится, тем не менее весь остальной синхронный код не использующий result будет выполнен как обычно.

// Задание "со звёздочкой":

// 1) Сначала без запуска подцумайте какой будет порядок вывода в консоль
// 2) Скопируйте и запустите код в любой консоли
// 3) А дальше прикрипите к дз подробное обьяснение по шагам о работе эвент лупа в этом коде и собственно объяснение почему выведеться именно в таком порядке

Promise.resolve() // синхронное выполенние функции resolve()
  .then(() => console.log("a: 1")) // 1. асинхронное выполение колбека в then, который через очередь микрозадач попадет обратно в стек, если он пустой, итог вызова then будем просто успешновыполеннный промис со значением undefined, так как колбек ничего не возвращает
  .then(() => {
    // асинхронноые выполение колбека в then
    setTimeout(() => console.log("timeout 2")); // 4. асинхронное выполнение колбека в setTimeout, попадет в Web Api, и выполнится с задержкой в 0 секунд через очередь макрозадач, если очередь макрозадач пуста
    console.log("a: 2"); // 2.асинхронно выполнится через очередь микрозадач со всеми другими функциями в микрозадачах если стек пуст
  })
  .then(() => {
    // асинхронноые выполение колбека в then
    setTimeout(() => console.log("timeout 3")); // 5. асинхронное выполнение колбека в setTimeout, попадет в Web Api, и выполнится с задержкой в 0 секунд через очередь макрозадач, если очередь макрозадач пуста
    console.log("a: 3"); // 3. асинхронно выполнится через очередь микрозадач со всеми другими функциями в микрозадачах если стек пуст
  });
// так как у нас есть микрозадачи и макрозадачи, то первыми в стек попадает пачка функций из микрозадач и уже потом по одной в стек попадают колбеки макрозадач, колбеки setTimeout
// вывод в консоль: a: 1, a: 2, a: 3, timeout 2, timeout 3

new Promise((res, rej) => {
  console.log("b"); // 1. синхронно логируем в консоль b
  rej(new Error("123")); // синхронно отклоняем промис со значением 123
}) // на отклоннном промисе со значение 123 вызываем then
  .then(console.log("b 1")) // в методе then не функция, поэтому код then просто выполняется не влияя никак на дальнейшую цепочку, тем не менее результатом этого then помимо вывода в консоль значения будет и отклоненный промис со значением 123, просто идет передача отклоненного промиса со значением 123 вперед
  .then(
    // вызываем метод then на отклоненном промисе со значением 123
    () => console.log("b 2"), // колбек игнорирется так как промис отклонен
    () => console.log("b"), // колбек логирует в консоль b, так как мы обрабатываем отклоненный промис
  ) // результат вызова then будет успешно выполненный промис, так как мы корректно обработали его методом, а его значение будет undefined так как мы не возвращали значение 123 во в втором колбеке then
  .catch(() => console.log("b 3")) // колбек в catch игнорируется так как вы вызываем catch на успешно завершенном промисе, результат вызова catch будет успешно выполненный промис
  .then(() => console.log("b 4")); // на успешно выполенном промисе вызываем then с колбеком который логирует b 4
// все колбеки в методах then и catch выполняются асинхронно попадая в очередь микрозадач и в дальнейшем попадая в стек всей пачкой
